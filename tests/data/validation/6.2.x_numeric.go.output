// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package test

import "fmt"
import "encoding/json"

type A62XNumeric struct {
	// MaxBoolIgnored corresponds to the JSON schema field "maxBoolIgnored".
	MaxBoolIgnored bool `json:"maxBoolIgnored" yaml:"maxBoolIgnored"`

	// MaxInt corresponds to the JSON schema field "maxInt".
	MaxInt int `json:"maxInt" yaml:"maxInt"`

	// MaxInt0Excl corresponds to the JSON schema field "maxInt0Excl".
	MaxInt0Excl int `json:"maxInt0Excl" yaml:"maxInt0Excl"`

	// MaxIntOpt corresponds to the JSON schema field "maxIntOpt".
	MaxIntOpt *int `json:"maxIntOpt,omitempty" yaml:"maxIntOpt,omitempty"`

	// MaxNum corresponds to the JSON schema field "maxNum".
	MaxNum float64 `json:"maxNum" yaml:"maxNum"`

	// MaxNum0 corresponds to the JSON schema field "maxNum0".
	MaxNum0 float64 `json:"maxNum0" yaml:"maxNum0"`

	// MaxNum0OptExcl corresponds to the JSON schema field "maxNum0OptExcl".
	MaxNum0OptExcl *float64 `json:"maxNum0OptExcl,omitempty" yaml:"maxNum0OptExcl,omitempty"`

	// MaxStringIgnored corresponds to the JSON schema field "maxStringIgnored".
	MaxStringIgnored string `json:"maxStringIgnored" yaml:"maxStringIgnored"`

	// MinBoolIgnored corresponds to the JSON schema field "minBoolIgnored".
	MinBoolIgnored bool `json:"minBoolIgnored" yaml:"minBoolIgnored"`

	// MinInt corresponds to the JSON schema field "minInt".
	MinInt int `json:"minInt" yaml:"minInt"`

	// MinInt0Excl corresponds to the JSON schema field "minInt0Excl".
	MinInt0Excl int `json:"minInt0Excl" yaml:"minInt0Excl"`

	// MinIntOpt corresponds to the JSON schema field "minIntOpt".
	MinIntOpt *int `json:"minIntOpt,omitempty" yaml:"minIntOpt,omitempty"`

	// MinMaxInt corresponds to the JSON schema field "minMaxInt".
	MinMaxInt int `json:"minMaxInt" yaml:"minMaxInt"`

	// MinNum corresponds to the JSON schema field "minNum".
	MinNum float64 `json:"minNum" yaml:"minNum"`

	// MinNum0 corresponds to the JSON schema field "minNum0".
	MinNum0 float64 `json:"minNum0" yaml:"minNum0"`

	// MinNum0OptExcl corresponds to the JSON schema field "minNum0OptExcl".
	MinNum0OptExcl *float64 `json:"minNum0OptExcl,omitempty" yaml:"minNum0OptExcl,omitempty"`

	// MinStringIgnored corresponds to the JSON schema field "minStringIgnored".
	MinStringIgnored string `json:"minStringIgnored" yaml:"minStringIgnored"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A62XNumeric) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["maxBoolIgnored"]; !ok || v == nil {
		return fmt.Errorf("field maxBoolIgnored in A62XNumeric: required")
	}
	if v, ok := raw["maxInt"]; !ok || v == nil {
		return fmt.Errorf("field maxInt in A62XNumeric: required")
	}
	if v, ok := raw["maxInt0Excl"]; !ok || v == nil {
		return fmt.Errorf("field maxInt0Excl in A62XNumeric: required")
	}
	if v, ok := raw["maxNum"]; !ok || v == nil {
		return fmt.Errorf("field maxNum in A62XNumeric: required")
	}
	if v, ok := raw["maxNum0"]; !ok || v == nil {
		return fmt.Errorf("field maxNum0 in A62XNumeric: required")
	}
	if v, ok := raw["maxStringIgnored"]; !ok || v == nil {
		return fmt.Errorf("field maxStringIgnored in A62XNumeric: required")
	}
	if v, ok := raw["minBoolIgnored"]; !ok || v == nil {
		return fmt.Errorf("field minBoolIgnored in A62XNumeric: required")
	}
	if v, ok := raw["minInt"]; !ok || v == nil {
		return fmt.Errorf("field minInt in A62XNumeric: required")
	}
	if v, ok := raw["minInt0Excl"]; !ok || v == nil {
		return fmt.Errorf("field minInt0Excl in A62XNumeric: required")
	}
	if v, ok := raw["minMaxInt"]; !ok || v == nil {
		return fmt.Errorf("field minMaxInt in A62XNumeric: required")
	}
	if v, ok := raw["minNum"]; !ok || v == nil {
		return fmt.Errorf("field minNum in A62XNumeric: required")
	}
	if v, ok := raw["minNum0"]; !ok || v == nil {
		return fmt.Errorf("field minNum0 in A62XNumeric: required")
	}
	if v, ok := raw["minStringIgnored"]; !ok || v == nil {
		return fmt.Errorf("field minStringIgnored in A62XNumeric: required")
	}
	type Plain A62XNumeric
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.MaxInt > 42 {
		return fmt.Errorf("field maxInt: must not be > 42")
	}
	if plain.MaxInt0Excl >= 0 {
		return fmt.Errorf("field maxInt0Excl: must not be >= 0")
	}
	if plain.MaxIntOpt != nil && *plain.MaxIntOpt > 0 {
		return fmt.Errorf("field maxIntOpt: must not be > 0")
	}
	if plain.MaxNum > -42 {
		return fmt.Errorf("field maxNum: must not be > -42")
	}
	if plain.MaxNum0 > 0 {
		return fmt.Errorf("field maxNum0: must not be > 0")
	}
	if plain.MaxNum0OptExcl != nil && *plain.MaxNum0OptExcl >= 0 {
		return fmt.Errorf("field maxNum0OptExcl: must not be >= 0")
	}
	if plain.MinInt < 3 {
		return fmt.Errorf("field minInt: must not be < 3")
	}
	if plain.MinInt0Excl <= 1024 {
		return fmt.Errorf("field minInt0Excl: must not be <= 1024")
	}
	if plain.MinIntOpt != nil && *plain.MinIntOpt < -42 {
		return fmt.Errorf("field minIntOpt: must not be < -42")
	}
	if plain.MinMaxInt > 10 {
		return fmt.Errorf("field minMaxInt: must not be > 10")
	}
	if plain.MinMaxInt < 3 {
		return fmt.Errorf("field minMaxInt: must not be < 3")
	}
	if plain.MinNum < -42 {
		return fmt.Errorf("field minNum: must not be < -42")
	}
	if plain.MinNum0 < 0 {
		return fmt.Errorf("field minNum0: must not be < 0")
	}
	if plain.MinNum0OptExcl != nil && *plain.MinNum0OptExcl <= 0 {
		return fmt.Errorf("field minNum0OptExcl: must not be <= 0")
	}
	*j = A62XNumeric(plain)
	return nil
}
